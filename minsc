#!/usr/bin/perl

use strict;
use warnings;

use POSIX qw(strftime);

sub usage;
sub fatal;
sub run;

use constant IMTMPL => 'i%04d.pnm';
use constant IMGLOB => 'i[0-9][0-9][0-9][0-9].*';

use constant MDTMPL => 'm%04d.%s';
use constant MDGLOB => 'm[0-9][0-9][0-9][0-9].*';

use constant RXIMFILE     => qr/^i([0-9]{4})\.([^.]+)$/;
use constant RXMDFILE     => qr/^m([0-9]{4})\.([^.]+)$/;
use constant RXMODE       => qr/^(?:gray|bw|color)$/i;
use constant RXRESOLUTION => qr/^[1-9]+00$/;
use constant RXIMDIMEN    => qr/^([0-9]+(?:\.[0-9]+)?)x([0-9]+(?:\.[0-9]+)?)$/;
use constant RXPAPERDIMEN => qr/^(?:letter|legal|a4)$/i;
use constant RXFLATBED    => qr/^(?:loop|flatbed)$/i;
use constant RXDUPLEX     => qr/^(?:adf|duplex)$/i;
use constant RXPROP       => qr/^([^=]+)=(.*)$/;
use constant RXPROJ       => qr/^(\/\S+)$/;

my $root  = $ENV{'MINSC_ROOT'}  ||= glob('~/etc/minsc') || '/usr/local/minsc';
my $spool = $ENV{'MINSC_SPOOL'} ||= glob('~/var/minsc') || '/var/local/minsc';  # || "$ENV{'MINSC_ROOT'}/spool";
my $prog        = 'scanadf';
my %prop        = ();
my %param       = qw( mode Gray resolution 200 width 215.889 height 279.400 source ADF );
my %mode        = qw( gray Gray bw Lineart color Color );
my %source      = ( 'adf' => 'ADF', 'duplex' => 'ADF Duplex' );
my %opt2toggle  = qw( n dry_run v verbose );
my %opt2param   = qw( m mode r resolution w width h height s source p prompt d destination );

my ($action, $proj, $mkdir, @destparts);

# --- Do stuff!

chdir $root or die;

read_options_from_file($_) for grep { -f } glob('@default');
parse_argv();

&{ $action || \&cmd_help };

# --- Commands

sub cmd_new {
    #@usage: new [@PROFILE]... [+/SUBDIR]... [MODE|RESOLUTION|DIMENS|SOURCE]...
    my ($dir, $mkdir) = mkdest(@destparts);
    die "Project #$dir already exists" if -d $dir;
    my $p = mkproj($dir);
    print '#', $p, "\n";
}

sub cmd_scan {
    #@usage: scan [PROJDIR] [@PROFILE]... [MODE|RESOLUTION|DIMENS|SOURCE]...
    usage if !defined $proj;
    chdir $proj or die;
    my @i = all_images();
    my $i = next_image_num();
    my @cmd = (
        $prog,
        -o => "$proj/".IMTMPL,
        -s => $i,
        -x => $param{'width'},
        -y => $param{'height'},
        '--resolution' => $param{'resolution'},
        '--mode' => $param{'mode'},
        '--source' => $param{'source'},
    );
    dry_run(@cmd) if $param{'dry_run'};
    my @time = gmtime;
    my %jobstart = (
        'user' => (getpwuid($<))[0],
        'date' => strftime('%Y%m%dT%H%M%SZ', @time),
    );
    mdwrite($i, 'jobstart', \%jobstart);
    my $err = run @cmd;
    my %scanned = map { $_ => 1 } all_images();
    delete @scanned{@i};
    @i = sort { $a <=> $b } keys %scanned;
    if (@i) {
        my %jobfinish = (
            'first' => $i[0],
            'last' => $i[-1],
            'count' => scalar(@i),
        );
        mdwrite($i[ 0], 'params',    \%param);
        mdwrite($i[ 0], 'props',     \%prop);
        mdwrite($i[-1], 'jobfinish', \%jobfinish);
    }
    die "Scan failed: $!" if $err;
}

sub cmd_loop {
    #@usage: loop [PROJDIR] [@PROFILE]... [MODE|RESOLUTION|DIMENS|SOURCE]...
    my @out;
    open my $tty, '>&', STDERR or die "Can't dup stderr: $!";
    open STDERR, '>', 'minsc.err' or die "Can't open minsc.err: $!";
    my $i = next_image_num();
    $prog = 'scanimage';
    my %scanned;
    while (1) {
        my $ans;
        print $tty 'Scan or quit? [Yq] ';
        sysread STDIN, $ans, 1;
        last if lc($ans) ne 'q';
        my $f = sprintf(IMTMPL, $i++);
        open STDOUT, '>', $f or die "Can't open output file $f: $!";
        my @cmd = (
            $prog,
            -s => $i,
            -x => $param{'width'},
            -y => $param{'height'},
            '--resolution' => $param{'resolution'},
            '--mode' => $param{'mode'},
            '--source' => $param{'source'},
        );
        run @cmd;
        $scanned{$f} = 1;
    }
    my @i = sort keys %scanned;
    if (@i) {
        $param{'count'} = scalar @i;
        mdwrite($i[0], 'params' => \%param);
        mdwrite($i[-1], 'props'  => \%prop);
    }
}

sub cmd_jobs {
    #@usage: jobs PROJDIR
    usage if !defined $proj;
    chdir $proj or fatal "Can't chdir $proj: $!";
    my @m = sort glob MDGLOB;
    my @js = grep /\.jobstart$/, @m;
    my @jf = grep /\.jobfinish$/, @m;
    return if !@js;
    printf "%-3s %-5s %-4s %-16s\n", qw(Num First Last Date);
    while (@js) {
        my ($s, $f, $js, $jf);
        $s = shift @js;
        $js = mdread(num($s), 'jobstart');
        if (@jf) {
            $f = shift @jf;
            $jf = mdread(num($f), 'jobfinish');
        }
        else {
            fatal;
        }
        my $job = {
            ( map { $_ => $js->{$_} } qw(date)             ),
            ( map { $_ => $jf->{$_} } qw(first last count) ),
        };
        printf "%3d %5d %4d %s\n", @$job{qw(count first last date)};
    }
}

sub cmd_make {
    #@usage: make PROJDIR -- [RANGE] [OUTSPEC].pdf
    usage if !defined $proj;
    chdir $proj or fatal "Can't chdir $proj: $!";
    usage if @ARGV < 1 || @ARGV > 2;
    my $out = pop @ARGV;
    my ($first, $last);
    if (@ARGV) {
        $ARGV[0] =~ /^(\d+)(?:-(\d*))?$/ or usage;
        ($first, $last) = ($1, $2);
    }
    elsif ($out =~ /^(\d+)(?:-(\d*))?\.pdf$/) {
        ($first, $last) = ($1, $2);
    }
    $last = !defined($last) ? $first : length($last) ? $last : 9999;
    my @i = grep { $_ >= $first && $_ <= $last } all_images();
    fatal "No images available" if !@i;
    ($first, $last) = ($i[0], $i[-1]);
    usage if $out !~ /^(.*)\.pdf$/;
    if (!length $1) {
        $out = ($first == $last) ? sprintf('made/%04d.pdf', $first)
                                 : sprintf('made/%04d-%04d.pdf', $first, $last)
                                 ;
        -d 'made' or mkdir 'made' or fatal "Can't mkdir made: $!";
    }
    elsif ($1 eq '-') {
        $out = 'pdf:-';
    }
    my @in = map { sprintf IMTMPL, $_ } @i;
    my $err = run qw(gm convert), @in, $out;
    fatal "make: gm exited with status $err" if $err;
}

# --- Other functions

sub num {
    return $1 if shift() =~ /(\d+)/;
}

sub all_images {
    my @i = sort glob IMGLOB;
    my $rx = RXIMFILE;
    s/$rx/$1/o for @i;
    return map { $_ + 0 } @i;
}

sub next_image_num {
    my @i = sort glob IMGLOB;
    return 1 if !@i;
    my $rx = RXIMFILE;
    s/$rx/$1/o for @i;
    return $i[-1] + 1;
}

sub mdread {
    my ($m, $k) = @_;
    my $mdfile = sprintf(MDTMPL, $m, $k);
    open my $fh, '<', $mdfile or die "Can't open $mdfile: $!";
    my %v;
    while (<$fh>) {
        $v{$1} = $2 if /^\s*([^#]\S*)\s+=\s+(.*)$/;
    }
    close $fh;
    return \%v;
}

sub mdwrite {
    my ($m, $k, $v) = @_;
    my $mdfile = sprintf(MDTMPL, $m, $k);
    open my $fh, '>', $mdfile or die "Can't open $mdfile: $!";
    print $fh mdval2str($v);
    close $fh;
}

sub mdval2str {
    local $_ = shift;
    my $r = ref;
    return $_ if $r eq '';
    return hash2str($_) if $r eq 'HASH';
}

sub hash2str {
    my ($h) = @_;
    my $str = '';
    foreach my $k (sort keys %$h) {
        my $v = $h->{$k};
        die if ref($v) ne '';
        $str .= "$k = $v\n";
    }
    return $str;
}

sub parse_argv {
    while (@ARGV) {
        my $arg = shift @ARGV;
        if ($arg =~ /^\@/) {
            read_options_from_file($arg);
        }
        elsif ($arg =~ RXPROJ) {
            $proj = $1;
        }
        elsif ($arg =~ /([a-z]\S+)/ && (my $code = __PACKAGE__->can("cmd_$1"))) {
            $action = $code;
        }
        elsif ($arg =~ /^-([a-z]+)/ && exists $opt2toggle{$1}) {
            my $opt = $1;
            $arg =~ s/^-.//;
            $param{$opt2toggle{$_} || usage} = 1 for split //, $opt;
            unshift @ARGV, "-$arg" if length $arg;
        }
        elsif ($arg =~ /^-([a-z])(.+)?$/ && exists $opt2param{$1}) {
            $param{$opt2param{$1}} = defined $2 ? $2 : !@ARGV ? usage : shift @ARGV;
        }
        elsif ($arg =~ m{^\+/}) {
            push @destparts, $arg;
        }
        elsif ($arg eq '--') {
            last;
        }
        elsif ($arg =~ RXMODE) {
            $param{'mode'} = $mode{lc $arg};
        }
        elsif ($arg =~ RXRESOLUTION) {
            $param{'resolution'} = $arg;
        }
        elsif ($arg =~ RXIMDIMEN) {
            @param{qw(weight height)} = ($1, $2);
        }
        elsif ($arg =~ RXPAPERDIMEN) {
            @param{qw(weight height)} = paper_dimens(lc $arg);
        }
        elsif ($arg =~ RXFLATBED) {
            $param{'source'} = 'Flatbed';
            $param{'prompt'} = 1;
            $action = \&cmd_loop;
        }
        elsif ($arg =~ RXDUPLEX) {
            $param{'source'} = $source{lc $arg};
        }
        elsif ($arg =~ RXPROP) {
            $prop{$1} = $2;
        }
        else {
            usage;
        }
    }
}

sub mkdest {
    my $mkdir;
    my @dp;
    foreach my $d (@_) {
        $d = glob($d) if $d =~ /^~/;
        if ($d =~ s{^\+(?=/)}{}) {
            @dp = ($spool) if !@dp;
            push @dp, $d;
            $mkdir = 1;
        }
        elsif ($d =~ m{^/}) {
            @dp = ($d);
        }
        elsif ($d =~ m{/}) {
            @dp = ($spool) if !@dp;
            push @dp, $d;
        }
        else {
            fatal "Bad destination part: $d";
        }
    }
    if (!@dp) {
        @dp = '$(r8h)';
        $mkdir = 1;
    }
    s/\$\(([^()]+)\)/expand($1)/eg for @dp;
    my $dir = join('/', @dp);
    $dir =~ s{//+}{/}g;
    return ($dir, $mkdir);
}


sub read_options_from_file {
    my ($f) = @_;
    open my $fh, '<', $f or die "Can't open $f: $!";
    while (<$fh>) {
        next if /^\s*(#.*)?$/;
        /^\s*(\S+)\s+(.*)$/
            or die "Bad line in profile $f $_";
        if ($1 eq 'destination') {
            push @destparts, $2;
        }
        elsif (defined $param{$1}) {
            $param{$1} = $2;
        }
        else {
            $prop{$1} = $2;
        }
    }
}

sub dry_run {
    my $cmdline = join(' ', map { quote($_) } @_);
    open my $tty, '>', '/dev/tty';
    print $tty "Dry run\n", $cmdline, "\n";
    exit 0;
}

sub quote {
    local $_ = shift;
    return $_ if !/[ "'\\]/;
    s/\\/\\\\/g;
    return qq{"$_"} if !/"/;
    return qq{'$_'} if !/'/;
    s/"/\\"/g;
    return qq{"$_"};
}

sub usage {
    print STDERR "usage: minsc COMMAND [ARG...]\n";
    exit 1;
}

sub fatal {
    print STDERR 'minsc: ', $_, "\n" for @_;
    exit 2;
}

sub run {
    system @_;
    return $? >> 8;
}

sub write_scan_properties {
    my %prop = @_;
    while (my ($f, $h) = each %prop) {
        open my $fh, '>>', $f or die "Can't open $f: $!";
        print $fh (map { "$_ $h->{$_}\n" } sort keys %$h), "\n";
    }
}

sub paper_dimens {
    my %dimens = (
        'letter' => [ 8.5 * 25.4, 11.0 * 25.4 ],
        'legal'  => [ 8.5 * 25.4, 14.0 * 25.4 ],  # XXX Really?
        'a4'     => [ 297.0, 210.0 ],
    );
    my $paper = lc shift;
    return @{ $dimens{$paper} || usage };
}

sub mkpath {
    my @mk;
    while (@_) {
        my $d = join('/', @_);
        last if -d $d;
        shift @_;
        unshift @mk, $d;
    }
    mkdir $_ or die "Can't mkdir $_: $!" for @mk;
}

sub expand {
    my ($key) = @_;
    return $prop{$key}  if exists $prop{$key};
    return $param{$key} if exists $param{$key};
    return sprintf("%0${1}d", int rand(10**$1)) if $key =~ /^r([1-9])d$/;
    return sprintf("%0${1}x", int rand(1<<(4*$1))) if $key =~ /^r([1-9])x$/;
    die;
    # $(r7d)
    # $(r4x)
    # $(start)
}

sub mkproj {
    my ($d) = @_;
    mkdir $d or die "Can't mkdir $d: $!";
    chdir $d or die "Can't chdir $d: $!";
    mdwrite(0, 'params' => \%param);
    mdwrite(0, 'props' => \%prop);
    return $d;
}

sub gather {
    my ($imlast, @mdlast);
    my (%image, %meta);
    foreach (sort glob IMGLOB) {
        die if $_ !~ RXIMFILE;
        my ($imi, $ext) = ($1, $2);
        $image{$imi} = $ext;
        $imlast = 'i'.$imi;
    }
    foreach (sort glob MDGLOB) {
        die if $_ !~ RXMDFILE;
        my ($mdi, $mdj, $mdt) = ($1, $2, $3);
        $meta{$mdi}{$mdj}{$mdt} = undef;
        @mdlast = ('m'.$mdi, $mdj);
    }
    my $imnext = $imlast || sprintf(IMTMPL, 1);
    $imnext++;
    my @mdnext = ($imnext, '01');
    $mdnext[0] =~ s/^i/m/;
    return {
        'images' => \%image,
        'imlast' => $imlast,
        'imnext' => $imnext,
        'metadata' => \%meta,
        'mdlast' => \@mdlast,
        'mdnext' => \@mdnext,
    };
}

